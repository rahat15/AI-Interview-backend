# apps/api/routers/interview_routes.py

from fastapi import APIRouter, HTTPException
from pydantic import BaseModel
from typing import Optional, Dict, Any, List
from interview.session_manager import interview_manager

# No prefix here; prefix is added in app.include_router
router = APIRouter(tags=["Interview"])

# ---------------------------
# Request / Response Schemas
# ---------------------------

class StartSessionRequest(BaseModel):
    user_id: str
    session_id: str
    role_title: str
    company_name: str
    industry: str
    jd: Optional[str] = ""
    cv: Optional[str] = ""
    round_type: Optional[str] = "full"


class StartSessionResponse(BaseModel):
    session_id: str
    user_id: str
    first_question: str
    state: Dict[str, Any]


class AnswerRequest(BaseModel):
    user_id: str
    session_id: str
    answer: str


class AnswerResponse(BaseModel):
    evaluation: Optional[Dict[str, Any]]
    next_question: Optional[str]
    state: Dict[str, Any]


class ReportResponse(BaseModel):
    session_id: str
    user_id: str
    role: str
    company: str
    industry: str
    avg_scores: Dict[str, Any]
    history: List[Dict[str, Any]]

# ---------------------------
# Routes
# ---------------------------

@router.post("/start", response_model=StartSessionResponse)
async def start_session(req: StartSessionRequest):
    """
    Start a new interview session.
    Creates a session, initializes state, and returns the first question.
    """
    try:
        state = interview_manager.create_session(
            user_id=req.user_id,
            session_id=req.session_id,
            role_title=req.role_title,
            company_name=req.company_name,
            industry=req.industry,
            jd=req.jd,
            cv=req.cv,
            round_type=req.round_type,
        )

        # Advance graph until first question
        result = await interview_manager.step(req.user_id, req.session_id)

        history = result.get("history", [])
        if not history:
            raise RuntimeError("No question generated by graph")

        first_question = history[-1]["question"]

        return {
            "user_id": req.user_id,
            "session_id": req.session_id,
            "first_question": first_question,
            "state": result,
        }
    except Exception as e:
        raise HTTPException(status_code=400, detail={"error": str(e)})


@router.post("/answer", response_model=AnswerResponse)
async def submit_answer(req: AnswerRequest):
    """
    Submit an answer to the current question.
    Evaluates response, decides follow-up/transition, and returns next question.
    """
    try:
        # 1. Run the graph
        result = await interview_manager.step(
            req.user_id,
            req.session_id,
            user_answer=req.answer,
        )

        history = result.get("history", [])
        
        # 2. Get the Next Question (The last thing added)
        # If the graph ended (completed), there might be no next question.
        last_item = history[-1] if history else {}
        next_question = last_item.get("question") if not result.get("completed") else None

        # 3. Get the Evaluation (The thing we just answered)
        # If we have at least 2 items (Old Q + New Q), the evaluation is in the second to last [-2].
        # If the interview is done (completed), the evaluation is in the last item [-1].
        if result.get("completed"):
            evaluated_item = last_item
        else:
            evaluated_item = history[-2] if len(history) >= 2 else {}

        return {
            "evaluation": evaluated_item.get("evaluation"), # Returns the score for the answer just given
            "next_question": next_question,
            "state": result,
        }
    except Exception as e:
        raise HTTPException(status_code=400, detail={"error": str(e)})


@router.get("/state/{user_id}/{session_id}")
def get_state(user_id: str, session_id: str):
    """
    Get the current interview state for a given session.
    """
    state = interview_manager.get_state(user_id, session_id)
    if not state:
        raise HTTPException(status_code=404, detail={"error": "Session not found"})
    return state


@router.get("/sessions/{user_id}")
def get_user_sessions(user_id: str):
    """
    Get all interview sessions for a specific user.
    """
    sessions = interview_manager.get_user_sessions(user_id)
    if not sessions:
        raise HTTPException(status_code=404, detail={"error": "No sessions found for user"})
    return sessions


@router.get("/report/{user_id}/{session_id}", response_model=ReportResponse)
def get_report(user_id: str, session_id: str):
    """
    Generate a structured summary report for an interview session.
    """
    report = interview_manager.generate_report(user_id, session_id)
    if "error" in report:
        raise HTTPException(status_code=404, detail=report)
    return report
